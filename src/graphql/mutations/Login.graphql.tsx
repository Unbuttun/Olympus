/* 7beb81e70bd34c9ecb54e69ba634b283be8fc47e
 * This file is automatically generated by graphql-let. */

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
import type { FieldPolicy, FieldReadFunction, TypePolicies, TypePolicy } from '@apollo/client/cache';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** The `BigInt` scalar type represents non-fractional signed whole numeric values. */
  BigInt: number;
  /** The javascript `Date` as string. Type represents date and time as the ISO Date string. */
  DateTime: Date;
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: any;
};

export type AffectedRowsOutput = {
  __typename?: 'AffectedRowsOutput';
  count: Scalars['Int'];
};

export type AggregateSession = {
  __typename?: 'AggregateSession';
  count?: Maybe<SessionCountAggregate>;
  min?: Maybe<SessionMinAggregate>;
  max?: Maybe<SessionMaxAggregate>;
};

export type AggregateTokens = {
  __typename?: 'AggregateTokens';
  count?: Maybe<TokensCountAggregate>;
  min?: Maybe<TokensMinAggregate>;
  max?: Maybe<TokensMaxAggregate>;
};

export type AggregateUser = {
  __typename?: 'AggregateUser';
  count?: Maybe<UserCountAggregate>;
  avg?: Maybe<UserAvgAggregate>;
  sum?: Maybe<UserSumAggregate>;
  min?: Maybe<UserMinAggregate>;
  max?: Maybe<UserMaxAggregate>;
};


export type BigIntFieldUpdateOperationsInput = {
  set?: Maybe<Scalars['BigInt']>;
  increment?: Maybe<Scalars['BigInt']>;
  decrement?: Maybe<Scalars['BigInt']>;
  multiply?: Maybe<Scalars['BigInt']>;
  divide?: Maybe<Scalars['BigInt']>;
};

export type BigIntFilter = {
  equals?: Maybe<Scalars['BigInt']>;
  in?: Maybe<Array<Scalars['BigInt']>>;
  notIn?: Maybe<Array<Scalars['BigInt']>>;
  lt?: Maybe<Scalars['BigInt']>;
  lte?: Maybe<Scalars['BigInt']>;
  gt?: Maybe<Scalars['BigInt']>;
  gte?: Maybe<Scalars['BigInt']>;
  not?: Maybe<NestedBigIntFilter>;
};

export type BigIntWithAggregatesFilter = {
  equals?: Maybe<Scalars['BigInt']>;
  in?: Maybe<Array<Scalars['BigInt']>>;
  notIn?: Maybe<Array<Scalars['BigInt']>>;
  lt?: Maybe<Scalars['BigInt']>;
  lte?: Maybe<Scalars['BigInt']>;
  gt?: Maybe<Scalars['BigInt']>;
  gte?: Maybe<Scalars['BigInt']>;
  not?: Maybe<NestedBigIntWithAggregatesFilter>;
  count?: Maybe<NestedIntFilter>;
  avg?: Maybe<NestedFloatFilter>;
  sum?: Maybe<NestedBigIntFilter>;
  min?: Maybe<NestedBigIntFilter>;
  max?: Maybe<NestedBigIntFilter>;
};

export type BoolFieldUpdateOperationsInput = {
  set?: Maybe<Scalars['Boolean']>;
};

export type BoolFilter = {
  equals?: Maybe<Scalars['Boolean']>;
  not?: Maybe<NestedBoolFilter>;
};

export type BoolWithAggregatesFilter = {
  equals?: Maybe<Scalars['Boolean']>;
  not?: Maybe<NestedBoolWithAggregatesFilter>;
  count?: Maybe<NestedIntFilter>;
  min?: Maybe<NestedBoolFilter>;
  max?: Maybe<NestedBoolFilter>;
};


export type DateTimeFieldUpdateOperationsInput = {
  set?: Maybe<Scalars['DateTime']>;
};

export type DateTimeFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeFilter>;
};

export type DateTimeWithAggregatesFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeWithAggregatesFilter>;
  count?: Maybe<NestedIntFilter>;
  min?: Maybe<NestedDateTimeFilter>;
  max?: Maybe<NestedDateTimeFilter>;
};

export type EnumPatronageNullableFilter = {
  equals?: Maybe<Patronage>;
  in?: Maybe<Array<Patronage>>;
  notIn?: Maybe<Array<Patronage>>;
  not?: Maybe<NestedEnumPatronageNullableFilter>;
};

export type EnumPatronageNullableWithAggregatesFilter = {
  equals?: Maybe<Patronage>;
  in?: Maybe<Array<Patronage>>;
  notIn?: Maybe<Array<Patronage>>;
  not?: Maybe<NestedEnumPatronageNullableWithAggregatesFilter>;
  count?: Maybe<NestedIntNullableFilter>;
  min?: Maybe<NestedEnumPatronageNullableFilter>;
  max?: Maybe<NestedEnumPatronageNullableFilter>;
};

export type EnumTokenTypeFieldUpdateOperationsInput = {
  set?: Maybe<TokenType>;
};

export type EnumTokenTypeFilter = {
  equals?: Maybe<TokenType>;
  in?: Maybe<Array<TokenType>>;
  notIn?: Maybe<Array<TokenType>>;
  not?: Maybe<NestedEnumTokenTypeFilter>;
};

export type EnumTokenTypeWithAggregatesFilter = {
  equals?: Maybe<TokenType>;
  in?: Maybe<Array<TokenType>>;
  notIn?: Maybe<Array<TokenType>>;
  not?: Maybe<NestedEnumTokenTypeWithAggregatesFilter>;
  count?: Maybe<NestedIntFilter>;
  min?: Maybe<NestedEnumTokenTypeFilter>;
  max?: Maybe<NestedEnumTokenTypeFilter>;
};

export type EnumUserRoleFieldUpdateOperationsInput = {
  set?: Maybe<UserRole>;
};

export type EnumUserRoleFilter = {
  equals?: Maybe<UserRole>;
  in?: Maybe<Array<UserRole>>;
  notIn?: Maybe<Array<UserRole>>;
  not?: Maybe<NestedEnumUserRoleFilter>;
};

export type EnumUserRoleWithAggregatesFilter = {
  equals?: Maybe<UserRole>;
  in?: Maybe<Array<UserRole>>;
  notIn?: Maybe<Array<UserRole>>;
  not?: Maybe<NestedEnumUserRoleWithAggregatesFilter>;
  count?: Maybe<NestedIntFilter>;
  min?: Maybe<NestedEnumUserRoleFilter>;
  max?: Maybe<NestedEnumUserRoleFilter>;
};

export type FieldError = {
  __typename?: 'FieldError';
  field: Scalars['String'];
  message: Scalars['String'];
};

export type IntNullableFilter = {
  equals?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  notIn?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntNullableFilter>;
};

export type IntNullableWithAggregatesFilter = {
  equals?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  notIn?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntNullableWithAggregatesFilter>;
  count?: Maybe<NestedIntNullableFilter>;
  avg?: Maybe<NestedFloatNullableFilter>;
  sum?: Maybe<NestedIntNullableFilter>;
  min?: Maybe<NestedIntNullableFilter>;
  max?: Maybe<NestedIntNullableFilter>;
};


export type JsonFilter = {
  equals?: Maybe<Scalars['JSON']>;
  not?: Maybe<Scalars['JSON']>;
};

export type JsonWithAggregatesFilter = {
  equals?: Maybe<Scalars['JSON']>;
  not?: Maybe<Scalars['JSON']>;
  count?: Maybe<NestedIntFilter>;
  min?: Maybe<NestedJsonFilter>;
  max?: Maybe<NestedJsonFilter>;
};

export type LoginInput = {
  email: Scalars['String'];
  password: Scalars['String'];
};

export type Mutation = {
  __typename?: 'Mutation';
  createSession: Session;
  createManySession: AffectedRowsOutput;
  deleteSession?: Maybe<Session>;
  updateSession?: Maybe<Session>;
  deleteManySession: AffectedRowsOutput;
  updateManySession: AffectedRowsOutput;
  upsertSession: Session;
  createTokens: Tokens;
  createManyTokens: AffectedRowsOutput;
  deleteTokens?: Maybe<Tokens>;
  updateTokens?: Maybe<Tokens>;
  deleteManyTokens: AffectedRowsOutput;
  updateManyTokens: AffectedRowsOutput;
  upsertTokens: Tokens;
  createUser: User;
  createManyUser: AffectedRowsOutput;
  deleteUser?: Maybe<User>;
  updateUser?: Maybe<User>;
  deleteManyUser: AffectedRowsOutput;
  updateManyUser: AffectedRowsOutput;
  upsertUser: User;
  login: UserResponse;
  register: UserResponse;
  verifyUser: Scalars['Boolean'];
  changePassword: UserResponse;
  forgetPassword: Scalars['Boolean'];
  logout: Scalars['Boolean'];
  requestVerificationAgain: Scalars['Boolean'];
};


export type MutationCreateSessionArgs = {
  data: SessionCreateInput;
};


export type MutationCreateManySessionArgs = {
  data: Array<SessionCreateManyInput>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};


export type MutationDeleteSessionArgs = {
  where: SessionWhereUniqueInput;
};


export type MutationUpdateSessionArgs = {
  data: SessionUpdateInput;
  where: SessionWhereUniqueInput;
};


export type MutationDeleteManySessionArgs = {
  where?: Maybe<SessionWhereInput>;
};


export type MutationUpdateManySessionArgs = {
  data: SessionUpdateManyMutationInput;
  where?: Maybe<SessionWhereInput>;
};


export type MutationUpsertSessionArgs = {
  where: SessionWhereUniqueInput;
  create: SessionCreateInput;
  update: SessionUpdateInput;
};


export type MutationCreateTokensArgs = {
  data: TokensCreateInput;
};


export type MutationCreateManyTokensArgs = {
  data: Array<TokensCreateManyInput>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};


export type MutationDeleteTokensArgs = {
  where: TokensWhereUniqueInput;
};


export type MutationUpdateTokensArgs = {
  data: TokensUpdateInput;
  where: TokensWhereUniqueInput;
};


export type MutationDeleteManyTokensArgs = {
  where?: Maybe<TokensWhereInput>;
};


export type MutationUpdateManyTokensArgs = {
  data: TokensUpdateManyMutationInput;
  where?: Maybe<TokensWhereInput>;
};


export type MutationUpsertTokensArgs = {
  where: TokensWhereUniqueInput;
  create: TokensCreateInput;
  update: TokensUpdateInput;
};


export type MutationCreateUserArgs = {
  data: UserCreateInput;
};


export type MutationCreateManyUserArgs = {
  data: Array<UserCreateManyInput>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};


export type MutationDeleteUserArgs = {
  where: UserWhereUniqueInput;
};


export type MutationUpdateUserArgs = {
  data: UserUpdateInput;
  where: UserWhereUniqueInput;
};


export type MutationDeleteManyUserArgs = {
  where?: Maybe<UserWhereInput>;
};


export type MutationUpdateManyUserArgs = {
  data: UserUpdateManyMutationInput;
  where?: Maybe<UserWhereInput>;
};


export type MutationUpsertUserArgs = {
  where: UserWhereUniqueInput;
  create: UserCreateInput;
  update: UserUpdateInput;
};


export type MutationLoginArgs = {
  options: LoginInput;
};


export type MutationRegisterArgs = {
  options: RegisterInput;
};


export type MutationVerifyUserArgs = {
  token: Scalars['String'];
};


export type MutationChangePasswordArgs = {
  newPassword: Scalars['String'];
  token: Scalars['String'];
};


export type MutationForgetPasswordArgs = {
  email: Scalars['String'];
};


export type MutationRequestVerificationAgainArgs = {
  email: Scalars['String'];
};

export type NestedBigIntFilter = {
  equals?: Maybe<Scalars['BigInt']>;
  in?: Maybe<Array<Scalars['BigInt']>>;
  notIn?: Maybe<Array<Scalars['BigInt']>>;
  lt?: Maybe<Scalars['BigInt']>;
  lte?: Maybe<Scalars['BigInt']>;
  gt?: Maybe<Scalars['BigInt']>;
  gte?: Maybe<Scalars['BigInt']>;
  not?: Maybe<NestedBigIntFilter>;
};

export type NestedBigIntWithAggregatesFilter = {
  equals?: Maybe<Scalars['BigInt']>;
  in?: Maybe<Array<Scalars['BigInt']>>;
  notIn?: Maybe<Array<Scalars['BigInt']>>;
  lt?: Maybe<Scalars['BigInt']>;
  lte?: Maybe<Scalars['BigInt']>;
  gt?: Maybe<Scalars['BigInt']>;
  gte?: Maybe<Scalars['BigInt']>;
  not?: Maybe<NestedBigIntWithAggregatesFilter>;
  count?: Maybe<NestedIntFilter>;
  avg?: Maybe<NestedFloatFilter>;
  sum?: Maybe<NestedBigIntFilter>;
  min?: Maybe<NestedBigIntFilter>;
  max?: Maybe<NestedBigIntFilter>;
};

export type NestedBoolFilter = {
  equals?: Maybe<Scalars['Boolean']>;
  not?: Maybe<NestedBoolFilter>;
};

export type NestedBoolWithAggregatesFilter = {
  equals?: Maybe<Scalars['Boolean']>;
  not?: Maybe<NestedBoolWithAggregatesFilter>;
  count?: Maybe<NestedIntFilter>;
  min?: Maybe<NestedBoolFilter>;
  max?: Maybe<NestedBoolFilter>;
};

export type NestedDateTimeFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeFilter>;
};

export type NestedDateTimeWithAggregatesFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeWithAggregatesFilter>;
  count?: Maybe<NestedIntFilter>;
  min?: Maybe<NestedDateTimeFilter>;
  max?: Maybe<NestedDateTimeFilter>;
};

export type NestedEnumPatronageNullableFilter = {
  equals?: Maybe<Patronage>;
  in?: Maybe<Array<Patronage>>;
  notIn?: Maybe<Array<Patronage>>;
  not?: Maybe<NestedEnumPatronageNullableFilter>;
};

export type NestedEnumPatronageNullableWithAggregatesFilter = {
  equals?: Maybe<Patronage>;
  in?: Maybe<Array<Patronage>>;
  notIn?: Maybe<Array<Patronage>>;
  not?: Maybe<NestedEnumPatronageNullableWithAggregatesFilter>;
  count?: Maybe<NestedIntNullableFilter>;
  min?: Maybe<NestedEnumPatronageNullableFilter>;
  max?: Maybe<NestedEnumPatronageNullableFilter>;
};

export type NestedEnumTokenTypeFilter = {
  equals?: Maybe<TokenType>;
  in?: Maybe<Array<TokenType>>;
  notIn?: Maybe<Array<TokenType>>;
  not?: Maybe<NestedEnumTokenTypeFilter>;
};

export type NestedEnumTokenTypeWithAggregatesFilter = {
  equals?: Maybe<TokenType>;
  in?: Maybe<Array<TokenType>>;
  notIn?: Maybe<Array<TokenType>>;
  not?: Maybe<NestedEnumTokenTypeWithAggregatesFilter>;
  count?: Maybe<NestedIntFilter>;
  min?: Maybe<NestedEnumTokenTypeFilter>;
  max?: Maybe<NestedEnumTokenTypeFilter>;
};

export type NestedEnumUserRoleFilter = {
  equals?: Maybe<UserRole>;
  in?: Maybe<Array<UserRole>>;
  notIn?: Maybe<Array<UserRole>>;
  not?: Maybe<NestedEnumUserRoleFilter>;
};

export type NestedEnumUserRoleWithAggregatesFilter = {
  equals?: Maybe<UserRole>;
  in?: Maybe<Array<UserRole>>;
  notIn?: Maybe<Array<UserRole>>;
  not?: Maybe<NestedEnumUserRoleWithAggregatesFilter>;
  count?: Maybe<NestedIntFilter>;
  min?: Maybe<NestedEnumUserRoleFilter>;
  max?: Maybe<NestedEnumUserRoleFilter>;
};

export type NestedFloatFilter = {
  equals?: Maybe<Scalars['Float']>;
  in?: Maybe<Array<Scalars['Float']>>;
  notIn?: Maybe<Array<Scalars['Float']>>;
  lt?: Maybe<Scalars['Float']>;
  lte?: Maybe<Scalars['Float']>;
  gt?: Maybe<Scalars['Float']>;
  gte?: Maybe<Scalars['Float']>;
  not?: Maybe<NestedFloatFilter>;
};

export type NestedFloatNullableFilter = {
  equals?: Maybe<Scalars['Float']>;
  in?: Maybe<Array<Scalars['Float']>>;
  notIn?: Maybe<Array<Scalars['Float']>>;
  lt?: Maybe<Scalars['Float']>;
  lte?: Maybe<Scalars['Float']>;
  gt?: Maybe<Scalars['Float']>;
  gte?: Maybe<Scalars['Float']>;
  not?: Maybe<NestedFloatNullableFilter>;
};

export type NestedIntFilter = {
  equals?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  notIn?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntFilter>;
};

export type NestedIntNullableFilter = {
  equals?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  notIn?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntNullableFilter>;
};

export type NestedIntNullableWithAggregatesFilter = {
  equals?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  notIn?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntNullableWithAggregatesFilter>;
  count?: Maybe<NestedIntNullableFilter>;
  avg?: Maybe<NestedFloatNullableFilter>;
  sum?: Maybe<NestedIntNullableFilter>;
  min?: Maybe<NestedIntNullableFilter>;
  max?: Maybe<NestedIntNullableFilter>;
};

export type NestedJsonFilter = {
  equals?: Maybe<Scalars['JSON']>;
  not?: Maybe<Scalars['JSON']>;
};

export type NestedStringFilter = {
  equals?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  notIn?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  contains?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  not?: Maybe<NestedStringFilter>;
};

export type NestedStringNullableFilter = {
  equals?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  notIn?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  contains?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  not?: Maybe<NestedStringNullableFilter>;
};

export type NestedStringNullableWithAggregatesFilter = {
  equals?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  notIn?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  contains?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  not?: Maybe<NestedStringNullableWithAggregatesFilter>;
  count?: Maybe<NestedIntNullableFilter>;
  min?: Maybe<NestedStringNullableFilter>;
  max?: Maybe<NestedStringNullableFilter>;
};

export type NestedStringWithAggregatesFilter = {
  equals?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  notIn?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  contains?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  not?: Maybe<NestedStringWithAggregatesFilter>;
  count?: Maybe<NestedIntFilter>;
  min?: Maybe<NestedStringFilter>;
  max?: Maybe<NestedStringFilter>;
};

export type NullableEnumPatronageFieldUpdateOperationsInput = {
  set?: Maybe<Patronage>;
};

export type NullableIntFieldUpdateOperationsInput = {
  set?: Maybe<Scalars['Int']>;
  increment?: Maybe<Scalars['Int']>;
  decrement?: Maybe<Scalars['Int']>;
  multiply?: Maybe<Scalars['Int']>;
  divide?: Maybe<Scalars['Int']>;
};

export type NullableStringFieldUpdateOperationsInput = {
  set?: Maybe<Scalars['String']>;
};

export enum Patronage {
  Gold = 'GOLD',
  Silver = 'SILVER',
  Copper = 'COPPER'
}

export type Query = {
  __typename?: 'Query';
  session?: Maybe<Session>;
  findFirstSession?: Maybe<Session>;
  sessions: Array<Session>;
  aggregateSession: AggregateSession;
  groupBySession: Array<SessionGroupBy>;
  findUniqueTokens?: Maybe<Tokens>;
  findFirstTokens?: Maybe<Tokens>;
  findManyTokens: Array<Tokens>;
  aggregateTokens: AggregateTokens;
  groupByTokens: Array<TokensGroupBy>;
  user?: Maybe<User>;
  findFirstUser?: Maybe<User>;
  users: Array<User>;
  aggregateUser: AggregateUser;
  groupByUser: Array<UserGroupBy>;
  me: UserResponse;
};


export type QuerySessionArgs = {
  where: SessionWhereUniqueInput;
};


export type QueryFindFirstSessionArgs = {
  where?: Maybe<SessionWhereInput>;
  orderBy?: Maybe<Array<SessionOrderByInput>>;
  cursor?: Maybe<SessionWhereUniqueInput>;
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  distinct?: Maybe<Array<SessionScalarFieldEnum>>;
};


export type QuerySessionsArgs = {
  where?: Maybe<SessionWhereInput>;
  orderBy?: Maybe<Array<SessionOrderByInput>>;
  cursor?: Maybe<SessionWhereUniqueInput>;
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  distinct?: Maybe<Array<SessionScalarFieldEnum>>;
};


export type QueryAggregateSessionArgs = {
  where?: Maybe<SessionWhereInput>;
  orderBy?: Maybe<Array<SessionOrderByInput>>;
  cursor?: Maybe<SessionWhereUniqueInput>;
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
};


export type QueryGroupBySessionArgs = {
  where?: Maybe<SessionWhereInput>;
  orderBy?: Maybe<Array<SessionOrderByInput>>;
  by: Array<SessionScalarFieldEnum>;
  having?: Maybe<SessionScalarWhereWithAggregatesInput>;
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
};


export type QueryFindUniqueTokensArgs = {
  where: TokensWhereUniqueInput;
};


export type QueryFindFirstTokensArgs = {
  where?: Maybe<TokensWhereInput>;
  orderBy?: Maybe<Array<TokensOrderByInput>>;
  cursor?: Maybe<TokensWhereUniqueInput>;
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  distinct?: Maybe<Array<TokensScalarFieldEnum>>;
};


export type QueryFindManyTokensArgs = {
  where?: Maybe<TokensWhereInput>;
  orderBy?: Maybe<Array<TokensOrderByInput>>;
  cursor?: Maybe<TokensWhereUniqueInput>;
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  distinct?: Maybe<Array<TokensScalarFieldEnum>>;
};


export type QueryAggregateTokensArgs = {
  where?: Maybe<TokensWhereInput>;
  orderBy?: Maybe<Array<TokensOrderByInput>>;
  cursor?: Maybe<TokensWhereUniqueInput>;
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
};


export type QueryGroupByTokensArgs = {
  where?: Maybe<TokensWhereInput>;
  orderBy?: Maybe<Array<TokensOrderByInput>>;
  by: Array<TokensScalarFieldEnum>;
  having?: Maybe<TokensScalarWhereWithAggregatesInput>;
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
};


export type QueryUserArgs = {
  where: UserWhereUniqueInput;
};


export type QueryFindFirstUserArgs = {
  where?: Maybe<UserWhereInput>;
  orderBy?: Maybe<Array<UserOrderByInput>>;
  cursor?: Maybe<UserWhereUniqueInput>;
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  distinct?: Maybe<Array<UserScalarFieldEnum>>;
};


export type QueryUsersArgs = {
  where?: Maybe<UserWhereInput>;
  orderBy?: Maybe<Array<UserOrderByInput>>;
  cursor?: Maybe<UserWhereUniqueInput>;
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  distinct?: Maybe<Array<UserScalarFieldEnum>>;
};


export type QueryAggregateUserArgs = {
  where?: Maybe<UserWhereInput>;
  orderBy?: Maybe<Array<UserOrderByInput>>;
  cursor?: Maybe<UserWhereUniqueInput>;
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
};


export type QueryGroupByUserArgs = {
  where?: Maybe<UserWhereInput>;
  orderBy?: Maybe<Array<UserOrderByInput>>;
  by: Array<UserScalarFieldEnum>;
  having?: Maybe<UserScalarWhereWithAggregatesInput>;
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
};

export enum QueryMode {
  Default = 'default',
  Insensitive = 'insensitive'
}

export type RegisterInput = {
  email: Scalars['String'];
  password: Scalars['String'];
  name: Scalars['String'];
};

export type Session = {
  __typename?: 'Session';
  sid: Scalars['String'];
  sess: Scalars['JSON'];
  expire: Scalars['DateTime'];
};

export type SessionCountAggregate = {
  __typename?: 'SessionCountAggregate';
  sid: Scalars['Int'];
  sess: Scalars['Int'];
  expire: Scalars['Int'];
  _all: Scalars['Int'];
};

export type SessionCreateInput = {
  sid: Scalars['String'];
  sess: Scalars['JSON'];
  expire: Scalars['DateTime'];
};

export type SessionCreateManyInput = {
  sid: Scalars['String'];
  sess: Scalars['JSON'];
  expire: Scalars['DateTime'];
};

export type SessionGroupBy = {
  __typename?: 'SessionGroupBy';
  sid: Scalars['String'];
  sess: Scalars['JSON'];
  expire: Scalars['DateTime'];
  count?: Maybe<SessionCountAggregate>;
  min?: Maybe<SessionMinAggregate>;
  max?: Maybe<SessionMaxAggregate>;
};

export type SessionMaxAggregate = {
  __typename?: 'SessionMaxAggregate';
  sid?: Maybe<Scalars['String']>;
  expire?: Maybe<Scalars['DateTime']>;
};

export type SessionMinAggregate = {
  __typename?: 'SessionMinAggregate';
  sid?: Maybe<Scalars['String']>;
  expire?: Maybe<Scalars['DateTime']>;
};

export type SessionOrderByInput = {
  sid?: Maybe<SortOrder>;
  sess?: Maybe<SortOrder>;
  expire?: Maybe<SortOrder>;
};

export enum SessionScalarFieldEnum {
  Sid = 'sid',
  Sess = 'sess',
  Expire = 'expire'
}

export type SessionScalarWhereWithAggregatesInput = {
  AND?: Maybe<Array<SessionScalarWhereWithAggregatesInput>>;
  OR?: Maybe<Array<SessionScalarWhereWithAggregatesInput>>;
  NOT?: Maybe<Array<SessionScalarWhereWithAggregatesInput>>;
  sid?: Maybe<StringWithAggregatesFilter>;
  sess?: Maybe<JsonWithAggregatesFilter>;
  expire?: Maybe<DateTimeWithAggregatesFilter>;
};

export type SessionUpdateInput = {
  sid?: Maybe<StringFieldUpdateOperationsInput>;
  sess?: Maybe<Scalars['JSON']>;
  expire?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type SessionUpdateManyMutationInput = {
  sid?: Maybe<StringFieldUpdateOperationsInput>;
  sess?: Maybe<Scalars['JSON']>;
  expire?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type SessionWhereInput = {
  AND?: Maybe<Array<SessionWhereInput>>;
  OR?: Maybe<Array<SessionWhereInput>>;
  NOT?: Maybe<Array<SessionWhereInput>>;
  sid?: Maybe<StringFilter>;
  sess?: Maybe<JsonFilter>;
  expire?: Maybe<DateTimeFilter>;
};

export type SessionWhereUniqueInput = {
  sid?: Maybe<Scalars['String']>;
};

export enum SortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type StringFieldUpdateOperationsInput = {
  set?: Maybe<Scalars['String']>;
};

export type StringFilter = {
  equals?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  notIn?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  contains?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  mode?: Maybe<QueryMode>;
  not?: Maybe<NestedStringFilter>;
};

export type StringNullableFilter = {
  equals?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  notIn?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  contains?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  mode?: Maybe<QueryMode>;
  not?: Maybe<NestedStringNullableFilter>;
};

export type StringNullableWithAggregatesFilter = {
  equals?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  notIn?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  contains?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  mode?: Maybe<QueryMode>;
  not?: Maybe<NestedStringNullableWithAggregatesFilter>;
  count?: Maybe<NestedIntNullableFilter>;
  min?: Maybe<NestedStringNullableFilter>;
  max?: Maybe<NestedStringNullableFilter>;
};

export type StringWithAggregatesFilter = {
  equals?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  notIn?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  contains?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  mode?: Maybe<QueryMode>;
  not?: Maybe<NestedStringWithAggregatesFilter>;
  count?: Maybe<NestedIntFilter>;
  min?: Maybe<NestedStringFilter>;
  max?: Maybe<NestedStringFilter>;
};

export enum TokenType {
  ForgetPassword = 'FORGET_PASSWORD',
  AccountVerification = 'ACCOUNT_VERIFICATION'
}

export type Tokens = {
  __typename?: 'Tokens';
  id: Scalars['String'];
  type: TokenType;
  userId: Scalars['String'];
  expire: Scalars['DateTime'];
  createdAt: Scalars['DateTime'];
  token: Scalars['String'];
};

export type TokensCountAggregate = {
  __typename?: 'TokensCountAggregate';
  id: Scalars['Int'];
  type: Scalars['Int'];
  userId: Scalars['Int'];
  expire: Scalars['Int'];
  createdAt: Scalars['Int'];
  token: Scalars['Int'];
  _all: Scalars['Int'];
};

export type TokensCreateInput = {
  id?: Maybe<Scalars['String']>;
  type: TokenType;
  userId: Scalars['String'];
  expire: Scalars['DateTime'];
  createdAt?: Maybe<Scalars['DateTime']>;
  token: Scalars['String'];
};

export type TokensCreateManyInput = {
  id?: Maybe<Scalars['String']>;
  type: TokenType;
  userId: Scalars['String'];
  expire: Scalars['DateTime'];
  createdAt?: Maybe<Scalars['DateTime']>;
  token: Scalars['String'];
};

export type TokensGroupBy = {
  __typename?: 'TokensGroupBy';
  id: Scalars['String'];
  type: TokenType;
  userId: Scalars['String'];
  expire: Scalars['DateTime'];
  createdAt: Scalars['DateTime'];
  token: Scalars['String'];
  count?: Maybe<TokensCountAggregate>;
  min?: Maybe<TokensMinAggregate>;
  max?: Maybe<TokensMaxAggregate>;
};

export type TokensMaxAggregate = {
  __typename?: 'TokensMaxAggregate';
  id?: Maybe<Scalars['String']>;
  type?: Maybe<TokenType>;
  userId?: Maybe<Scalars['String']>;
  expire?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  token?: Maybe<Scalars['String']>;
};

export type TokensMinAggregate = {
  __typename?: 'TokensMinAggregate';
  id?: Maybe<Scalars['String']>;
  type?: Maybe<TokenType>;
  userId?: Maybe<Scalars['String']>;
  expire?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  token?: Maybe<Scalars['String']>;
};

export type TokensOrderByInput = {
  id?: Maybe<SortOrder>;
  type?: Maybe<SortOrder>;
  userId?: Maybe<SortOrder>;
  expire?: Maybe<SortOrder>;
  createdAt?: Maybe<SortOrder>;
  token?: Maybe<SortOrder>;
};

export enum TokensScalarFieldEnum {
  Id = 'id',
  Type = 'type',
  UserId = 'userId',
  Expire = 'expire',
  CreatedAt = 'createdAt',
  Token = 'token'
}

export type TokensScalarWhereWithAggregatesInput = {
  AND?: Maybe<Array<TokensScalarWhereWithAggregatesInput>>;
  OR?: Maybe<Array<TokensScalarWhereWithAggregatesInput>>;
  NOT?: Maybe<Array<TokensScalarWhereWithAggregatesInput>>;
  id?: Maybe<StringWithAggregatesFilter>;
  type?: Maybe<EnumTokenTypeWithAggregatesFilter>;
  userId?: Maybe<StringWithAggregatesFilter>;
  expire?: Maybe<DateTimeWithAggregatesFilter>;
  createdAt?: Maybe<DateTimeWithAggregatesFilter>;
  token?: Maybe<StringWithAggregatesFilter>;
};

export type TokensUpdateInput = {
  id?: Maybe<StringFieldUpdateOperationsInput>;
  type?: Maybe<EnumTokenTypeFieldUpdateOperationsInput>;
  userId?: Maybe<StringFieldUpdateOperationsInput>;
  expire?: Maybe<DateTimeFieldUpdateOperationsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  token?: Maybe<StringFieldUpdateOperationsInput>;
};

export type TokensUpdateManyMutationInput = {
  id?: Maybe<StringFieldUpdateOperationsInput>;
  type?: Maybe<EnumTokenTypeFieldUpdateOperationsInput>;
  userId?: Maybe<StringFieldUpdateOperationsInput>;
  expire?: Maybe<DateTimeFieldUpdateOperationsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  token?: Maybe<StringFieldUpdateOperationsInput>;
};

export type TokensWhereInput = {
  AND?: Maybe<Array<TokensWhereInput>>;
  OR?: Maybe<Array<TokensWhereInput>>;
  NOT?: Maybe<Array<TokensWhereInput>>;
  id?: Maybe<StringFilter>;
  type?: Maybe<EnumTokenTypeFilter>;
  userId?: Maybe<StringFilter>;
  expire?: Maybe<DateTimeFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  token?: Maybe<StringFilter>;
};

export type TokensWhereUniqueInput = {
  id?: Maybe<Scalars['String']>;
  token?: Maybe<Scalars['String']>;
};

export type User = {
  __typename?: 'User';
  id: Scalars['String'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  name?: Maybe<Scalars['String']>;
  role: UserRole;
  email: Scalars['String'];
  verified: Scalars['Boolean'];
  stripeId?: Maybe<Scalars['String']>;
  coins: Scalars['BigInt'];
  ccLast4?: Maybe<Scalars['Int']>;
  patronageType?: Maybe<Patronage>;
};

export type UserAvgAggregate = {
  __typename?: 'UserAvgAggregate';
  coins?: Maybe<Scalars['Float']>;
  ccLast4?: Maybe<Scalars['Float']>;
};

export type UserCountAggregate = {
  __typename?: 'UserCountAggregate';
  id: Scalars['Int'];
  createdAt: Scalars['Int'];
  updatedAt: Scalars['Int'];
  name: Scalars['Int'];
  role: Scalars['Int'];
  email: Scalars['Int'];
  password: Scalars['Int'];
  verified: Scalars['Int'];
  stripeId: Scalars['Int'];
  coins: Scalars['Int'];
  ccLast4: Scalars['Int'];
  patronageType: Scalars['Int'];
  _all: Scalars['Int'];
};

export type UserCreateInput = {
  id?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  name?: Maybe<Scalars['String']>;
  role?: Maybe<UserRole>;
  email: Scalars['String'];
  password: Scalars['String'];
  verified?: Maybe<Scalars['Boolean']>;
  stripeId?: Maybe<Scalars['String']>;
  coins?: Maybe<Scalars['BigInt']>;
  ccLast4?: Maybe<Scalars['Int']>;
  patronageType?: Maybe<Patronage>;
};

export type UserCreateManyInput = {
  id?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  name?: Maybe<Scalars['String']>;
  role?: Maybe<UserRole>;
  email: Scalars['String'];
  password: Scalars['String'];
  verified?: Maybe<Scalars['Boolean']>;
  stripeId?: Maybe<Scalars['String']>;
  coins?: Maybe<Scalars['BigInt']>;
  ccLast4?: Maybe<Scalars['Int']>;
  patronageType?: Maybe<Patronage>;
};

export type UserGroupBy = {
  __typename?: 'UserGroupBy';
  id: Scalars['String'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  name?: Maybe<Scalars['String']>;
  role: UserRole;
  email: Scalars['String'];
  password: Scalars['String'];
  verified: Scalars['Boolean'];
  stripeId?: Maybe<Scalars['String']>;
  coins: Scalars['BigInt'];
  ccLast4?: Maybe<Scalars['Int']>;
  patronageType?: Maybe<Patronage>;
  count?: Maybe<UserCountAggregate>;
  avg?: Maybe<UserAvgAggregate>;
  sum?: Maybe<UserSumAggregate>;
  min?: Maybe<UserMinAggregate>;
  max?: Maybe<UserMaxAggregate>;
};

export type UserMaxAggregate = {
  __typename?: 'UserMaxAggregate';
  id?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  name?: Maybe<Scalars['String']>;
  role?: Maybe<UserRole>;
  email?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  verified?: Maybe<Scalars['Boolean']>;
  stripeId?: Maybe<Scalars['String']>;
  coins?: Maybe<Scalars['BigInt']>;
  ccLast4?: Maybe<Scalars['Int']>;
  patronageType?: Maybe<Patronage>;
};

export type UserMinAggregate = {
  __typename?: 'UserMinAggregate';
  id?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  name?: Maybe<Scalars['String']>;
  role?: Maybe<UserRole>;
  email?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  verified?: Maybe<Scalars['Boolean']>;
  stripeId?: Maybe<Scalars['String']>;
  coins?: Maybe<Scalars['BigInt']>;
  ccLast4?: Maybe<Scalars['Int']>;
  patronageType?: Maybe<Patronage>;
};

export type UserOrderByInput = {
  id?: Maybe<SortOrder>;
  createdAt?: Maybe<SortOrder>;
  updatedAt?: Maybe<SortOrder>;
  name?: Maybe<SortOrder>;
  role?: Maybe<SortOrder>;
  email?: Maybe<SortOrder>;
  password?: Maybe<SortOrder>;
  verified?: Maybe<SortOrder>;
  stripeId?: Maybe<SortOrder>;
  coins?: Maybe<SortOrder>;
  ccLast4?: Maybe<SortOrder>;
  patronageType?: Maybe<SortOrder>;
};

export type UserResponse = {
  __typename?: 'UserResponse';
  errors?: Maybe<Array<FieldError>>;
  user?: Maybe<User>;
};

export enum UserRole {
  Admin = 'ADMIN',
  Moderator = 'MODERATOR',
  Premium = 'PREMIUM',
  Normal = 'NORMAL'
}

export enum UserScalarFieldEnum {
  Id = 'id',
  CreatedAt = 'createdAt',
  UpdatedAt = 'updatedAt',
  Name = 'name',
  Role = 'role',
  Email = 'email',
  Password = 'password',
  Verified = 'verified',
  StripeId = 'stripeId',
  Coins = 'coins',
  CcLast4 = 'ccLast4',
  PatronageType = 'patronageType'
}

export type UserScalarWhereWithAggregatesInput = {
  AND?: Maybe<Array<UserScalarWhereWithAggregatesInput>>;
  OR?: Maybe<Array<UserScalarWhereWithAggregatesInput>>;
  NOT?: Maybe<Array<UserScalarWhereWithAggregatesInput>>;
  id?: Maybe<StringWithAggregatesFilter>;
  createdAt?: Maybe<DateTimeWithAggregatesFilter>;
  updatedAt?: Maybe<DateTimeWithAggregatesFilter>;
  name?: Maybe<StringNullableWithAggregatesFilter>;
  role?: Maybe<EnumUserRoleWithAggregatesFilter>;
  email?: Maybe<StringWithAggregatesFilter>;
  password?: Maybe<StringWithAggregatesFilter>;
  verified?: Maybe<BoolWithAggregatesFilter>;
  stripeId?: Maybe<StringNullableWithAggregatesFilter>;
  coins?: Maybe<BigIntWithAggregatesFilter>;
  ccLast4?: Maybe<IntNullableWithAggregatesFilter>;
  patronageType?: Maybe<EnumPatronageNullableWithAggregatesFilter>;
};

export type UserSumAggregate = {
  __typename?: 'UserSumAggregate';
  coins?: Maybe<Scalars['BigInt']>;
  ccLast4?: Maybe<Scalars['Int']>;
};

export type UserUpdateInput = {
  id?: Maybe<StringFieldUpdateOperationsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  name?: Maybe<NullableStringFieldUpdateOperationsInput>;
  role?: Maybe<EnumUserRoleFieldUpdateOperationsInput>;
  email?: Maybe<StringFieldUpdateOperationsInput>;
  password?: Maybe<StringFieldUpdateOperationsInput>;
  verified?: Maybe<BoolFieldUpdateOperationsInput>;
  stripeId?: Maybe<NullableStringFieldUpdateOperationsInput>;
  coins?: Maybe<BigIntFieldUpdateOperationsInput>;
  ccLast4?: Maybe<NullableIntFieldUpdateOperationsInput>;
  patronageType?: Maybe<NullableEnumPatronageFieldUpdateOperationsInput>;
};

export type UserUpdateManyMutationInput = {
  id?: Maybe<StringFieldUpdateOperationsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  name?: Maybe<NullableStringFieldUpdateOperationsInput>;
  role?: Maybe<EnumUserRoleFieldUpdateOperationsInput>;
  email?: Maybe<StringFieldUpdateOperationsInput>;
  password?: Maybe<StringFieldUpdateOperationsInput>;
  verified?: Maybe<BoolFieldUpdateOperationsInput>;
  stripeId?: Maybe<NullableStringFieldUpdateOperationsInput>;
  coins?: Maybe<BigIntFieldUpdateOperationsInput>;
  ccLast4?: Maybe<NullableIntFieldUpdateOperationsInput>;
  patronageType?: Maybe<NullableEnumPatronageFieldUpdateOperationsInput>;
};

export type UserWhereInput = {
  AND?: Maybe<Array<UserWhereInput>>;
  OR?: Maybe<Array<UserWhereInput>>;
  NOT?: Maybe<Array<UserWhereInput>>;
  id?: Maybe<StringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  name?: Maybe<StringNullableFilter>;
  role?: Maybe<EnumUserRoleFilter>;
  email?: Maybe<StringFilter>;
  password?: Maybe<StringFilter>;
  verified?: Maybe<BoolFilter>;
  stripeId?: Maybe<StringNullableFilter>;
  coins?: Maybe<BigIntFilter>;
  ccLast4?: Maybe<IntNullableFilter>;
  patronageType?: Maybe<EnumPatronageNullableFilter>;
};

export type UserWhereUniqueInput = {
  id?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  stripeId?: Maybe<Scalars['String']>;
};

export type LoginMutationVariables = Exact<{
  email: Scalars['String'];
  password: Scalars['String'];
}>;


export type LoginMutation = (
  { __typename?: 'Mutation' }
  & { login: (
    { __typename?: 'UserResponse' }
    & RegularUserResponseFragment
  ) }
);

export type RegularUserResponseFragment = (
  { __typename?: 'UserResponse' }
  & { errors?: Maybe<Array<(
    { __typename?: 'FieldError' }
    & RegularErrorFragment
  )>>, user?: Maybe<(
    { __typename?: 'User' }
    & RegularUserFragment
  )> }
);

export type RegularErrorFragment = (
  { __typename: 'FieldError' }
  & Pick<FieldError, 'field' | 'message'>
);

export type RegularUserFragment = (
  { __typename: 'User' }
  & Pick<User, 'id' | 'name' | 'email'>
);

export const RegularErrorFragmentDoc = gql`
    fragment RegularError on FieldError {
  field
  message
  __typename
}
    `;
export const RegularUserFragmentDoc = gql`
    fragment RegularUser on User {
  id
  name
  email
  __typename
}
    `;
export const RegularUserResponseFragmentDoc = gql`
    fragment RegularUserResponse on UserResponse {
  errors {
    ...RegularError
  }
  user {
    ...RegularUser
  }
}
    ${RegularErrorFragmentDoc}
${RegularUserFragmentDoc}`;
export const LoginDocument = gql`
    mutation Login($email: String!, $password: String!) {
  login(options: {email: $email, password: $password}) {
    ...RegularUserResponse
  }
}
    ${RegularUserResponseFragmentDoc}`;
export type LoginMutationFn = Apollo.MutationFunction<LoginMutation, LoginMutationVariables>;

/**
 * __useLoginMutation__
 *
 * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginMutation, { data, loading, error }] = useLoginMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useLoginMutation(baseOptions?: Apollo.MutationHookOptions<LoginMutation, LoginMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument, options);
      }
export type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;
export type LoginMutationResult = Apollo.MutationResult<LoginMutation>;
export type LoginMutationOptions = Apollo.BaseMutationOptions<LoginMutation, LoginMutationVariables>;
export type AffectedRowsOutputKeySpecifier = ('count' | AffectedRowsOutputKeySpecifier)[];
export type AffectedRowsOutputFieldPolicy = {
	count?: FieldPolicy<any> | FieldReadFunction<any>
};
export type AggregateSessionKeySpecifier = ('count' | 'min' | 'max' | AggregateSessionKeySpecifier)[];
export type AggregateSessionFieldPolicy = {
	count?: FieldPolicy<any> | FieldReadFunction<any>,
	min?: FieldPolicy<any> | FieldReadFunction<any>,
	max?: FieldPolicy<any> | FieldReadFunction<any>
};
export type AggregateTokensKeySpecifier = ('count' | 'min' | 'max' | AggregateTokensKeySpecifier)[];
export type AggregateTokensFieldPolicy = {
	count?: FieldPolicy<any> | FieldReadFunction<any>,
	min?: FieldPolicy<any> | FieldReadFunction<any>,
	max?: FieldPolicy<any> | FieldReadFunction<any>
};
export type AggregateUserKeySpecifier = ('count' | 'avg' | 'sum' | 'min' | 'max' | AggregateUserKeySpecifier)[];
export type AggregateUserFieldPolicy = {
	count?: FieldPolicy<any> | FieldReadFunction<any>,
	avg?: FieldPolicy<any> | FieldReadFunction<any>,
	sum?: FieldPolicy<any> | FieldReadFunction<any>,
	min?: FieldPolicy<any> | FieldReadFunction<any>,
	max?: FieldPolicy<any> | FieldReadFunction<any>
};
export type FieldErrorKeySpecifier = ('field' | 'message' | FieldErrorKeySpecifier)[];
export type FieldErrorFieldPolicy = {
	field?: FieldPolicy<any> | FieldReadFunction<any>,
	message?: FieldPolicy<any> | FieldReadFunction<any>
};
export type MutationKeySpecifier = ('createSession' | 'createManySession' | 'deleteSession' | 'updateSession' | 'deleteManySession' | 'updateManySession' | 'upsertSession' | 'createTokens' | 'createManyTokens' | 'deleteTokens' | 'updateTokens' | 'deleteManyTokens' | 'updateManyTokens' | 'upsertTokens' | 'createUser' | 'createManyUser' | 'deleteUser' | 'updateUser' | 'deleteManyUser' | 'updateManyUser' | 'upsertUser' | 'login' | 'register' | 'verifyUser' | 'changePassword' | 'forgetPassword' | 'logout' | 'requestVerificationAgain' | MutationKeySpecifier)[];
export type MutationFieldPolicy = {
	createSession?: FieldPolicy<any> | FieldReadFunction<any>,
	createManySession?: FieldPolicy<any> | FieldReadFunction<any>,
	deleteSession?: FieldPolicy<any> | FieldReadFunction<any>,
	updateSession?: FieldPolicy<any> | FieldReadFunction<any>,
	deleteManySession?: FieldPolicy<any> | FieldReadFunction<any>,
	updateManySession?: FieldPolicy<any> | FieldReadFunction<any>,
	upsertSession?: FieldPolicy<any> | FieldReadFunction<any>,
	createTokens?: FieldPolicy<any> | FieldReadFunction<any>,
	createManyTokens?: FieldPolicy<any> | FieldReadFunction<any>,
	deleteTokens?: FieldPolicy<any> | FieldReadFunction<any>,
	updateTokens?: FieldPolicy<any> | FieldReadFunction<any>,
	deleteManyTokens?: FieldPolicy<any> | FieldReadFunction<any>,
	updateManyTokens?: FieldPolicy<any> | FieldReadFunction<any>,
	upsertTokens?: FieldPolicy<any> | FieldReadFunction<any>,
	createUser?: FieldPolicy<any> | FieldReadFunction<any>,
	createManyUser?: FieldPolicy<any> | FieldReadFunction<any>,
	deleteUser?: FieldPolicy<any> | FieldReadFunction<any>,
	updateUser?: FieldPolicy<any> | FieldReadFunction<any>,
	deleteManyUser?: FieldPolicy<any> | FieldReadFunction<any>,
	updateManyUser?: FieldPolicy<any> | FieldReadFunction<any>,
	upsertUser?: FieldPolicy<any> | FieldReadFunction<any>,
	login?: FieldPolicy<any> | FieldReadFunction<any>,
	register?: FieldPolicy<any> | FieldReadFunction<any>,
	verifyUser?: FieldPolicy<any> | FieldReadFunction<any>,
	changePassword?: FieldPolicy<any> | FieldReadFunction<any>,
	forgetPassword?: FieldPolicy<any> | FieldReadFunction<any>,
	logout?: FieldPolicy<any> | FieldReadFunction<any>,
	requestVerificationAgain?: FieldPolicy<any> | FieldReadFunction<any>
};
export type QueryKeySpecifier = ('session' | 'findFirstSession' | 'sessions' | 'aggregateSession' | 'groupBySession' | 'findUniqueTokens' | 'findFirstTokens' | 'findManyTokens' | 'aggregateTokens' | 'groupByTokens' | 'user' | 'findFirstUser' | 'users' | 'aggregateUser' | 'groupByUser' | 'me' | QueryKeySpecifier)[];
export type QueryFieldPolicy = {
	session?: FieldPolicy<any> | FieldReadFunction<any>,
	findFirstSession?: FieldPolicy<any> | FieldReadFunction<any>,
	sessions?: FieldPolicy<any> | FieldReadFunction<any>,
	aggregateSession?: FieldPolicy<any> | FieldReadFunction<any>,
	groupBySession?: FieldPolicy<any> | FieldReadFunction<any>,
	findUniqueTokens?: FieldPolicy<any> | FieldReadFunction<any>,
	findFirstTokens?: FieldPolicy<any> | FieldReadFunction<any>,
	findManyTokens?: FieldPolicy<any> | FieldReadFunction<any>,
	aggregateTokens?: FieldPolicy<any> | FieldReadFunction<any>,
	groupByTokens?: FieldPolicy<any> | FieldReadFunction<any>,
	user?: FieldPolicy<any> | FieldReadFunction<any>,
	findFirstUser?: FieldPolicy<any> | FieldReadFunction<any>,
	users?: FieldPolicy<any> | FieldReadFunction<any>,
	aggregateUser?: FieldPolicy<any> | FieldReadFunction<any>,
	groupByUser?: FieldPolicy<any> | FieldReadFunction<any>,
	me?: FieldPolicy<any> | FieldReadFunction<any>
};
export type SessionKeySpecifier = ('sid' | 'sess' | 'expire' | SessionKeySpecifier)[];
export type SessionFieldPolicy = {
	sid?: FieldPolicy<any> | FieldReadFunction<any>,
	sess?: FieldPolicy<any> | FieldReadFunction<any>,
	expire?: FieldPolicy<any> | FieldReadFunction<any>
};
export type SessionCountAggregateKeySpecifier = ('sid' | 'sess' | 'expire' | '_all' | SessionCountAggregateKeySpecifier)[];
export type SessionCountAggregateFieldPolicy = {
	sid?: FieldPolicy<any> | FieldReadFunction<any>,
	sess?: FieldPolicy<any> | FieldReadFunction<any>,
	expire?: FieldPolicy<any> | FieldReadFunction<any>,
	_all?: FieldPolicy<any> | FieldReadFunction<any>
};
export type SessionGroupByKeySpecifier = ('sid' | 'sess' | 'expire' | 'count' | 'min' | 'max' | SessionGroupByKeySpecifier)[];
export type SessionGroupByFieldPolicy = {
	sid?: FieldPolicy<any> | FieldReadFunction<any>,
	sess?: FieldPolicy<any> | FieldReadFunction<any>,
	expire?: FieldPolicy<any> | FieldReadFunction<any>,
	count?: FieldPolicy<any> | FieldReadFunction<any>,
	min?: FieldPolicy<any> | FieldReadFunction<any>,
	max?: FieldPolicy<any> | FieldReadFunction<any>
};
export type SessionMaxAggregateKeySpecifier = ('sid' | 'expire' | SessionMaxAggregateKeySpecifier)[];
export type SessionMaxAggregateFieldPolicy = {
	sid?: FieldPolicy<any> | FieldReadFunction<any>,
	expire?: FieldPolicy<any> | FieldReadFunction<any>
};
export type SessionMinAggregateKeySpecifier = ('sid' | 'expire' | SessionMinAggregateKeySpecifier)[];
export type SessionMinAggregateFieldPolicy = {
	sid?: FieldPolicy<any> | FieldReadFunction<any>,
	expire?: FieldPolicy<any> | FieldReadFunction<any>
};
export type TokensKeySpecifier = ('id' | 'type' | 'userId' | 'expire' | 'createdAt' | 'token' | TokensKeySpecifier)[];
export type TokensFieldPolicy = {
	id?: FieldPolicy<any> | FieldReadFunction<any>,
	type?: FieldPolicy<any> | FieldReadFunction<any>,
	userId?: FieldPolicy<any> | FieldReadFunction<any>,
	expire?: FieldPolicy<any> | FieldReadFunction<any>,
	createdAt?: FieldPolicy<any> | FieldReadFunction<any>,
	token?: FieldPolicy<any> | FieldReadFunction<any>
};
export type TokensCountAggregateKeySpecifier = ('id' | 'type' | 'userId' | 'expire' | 'createdAt' | 'token' | '_all' | TokensCountAggregateKeySpecifier)[];
export type TokensCountAggregateFieldPolicy = {
	id?: FieldPolicy<any> | FieldReadFunction<any>,
	type?: FieldPolicy<any> | FieldReadFunction<any>,
	userId?: FieldPolicy<any> | FieldReadFunction<any>,
	expire?: FieldPolicy<any> | FieldReadFunction<any>,
	createdAt?: FieldPolicy<any> | FieldReadFunction<any>,
	token?: FieldPolicy<any> | FieldReadFunction<any>,
	_all?: FieldPolicy<any> | FieldReadFunction<any>
};
export type TokensGroupByKeySpecifier = ('id' | 'type' | 'userId' | 'expire' | 'createdAt' | 'token' | 'count' | 'min' | 'max' | TokensGroupByKeySpecifier)[];
export type TokensGroupByFieldPolicy = {
	id?: FieldPolicy<any> | FieldReadFunction<any>,
	type?: FieldPolicy<any> | FieldReadFunction<any>,
	userId?: FieldPolicy<any> | FieldReadFunction<any>,
	expire?: FieldPolicy<any> | FieldReadFunction<any>,
	createdAt?: FieldPolicy<any> | FieldReadFunction<any>,
	token?: FieldPolicy<any> | FieldReadFunction<any>,
	count?: FieldPolicy<any> | FieldReadFunction<any>,
	min?: FieldPolicy<any> | FieldReadFunction<any>,
	max?: FieldPolicy<any> | FieldReadFunction<any>
};
export type TokensMaxAggregateKeySpecifier = ('id' | 'type' | 'userId' | 'expire' | 'createdAt' | 'token' | TokensMaxAggregateKeySpecifier)[];
export type TokensMaxAggregateFieldPolicy = {
	id?: FieldPolicy<any> | FieldReadFunction<any>,
	type?: FieldPolicy<any> | FieldReadFunction<any>,
	userId?: FieldPolicy<any> | FieldReadFunction<any>,
	expire?: FieldPolicy<any> | FieldReadFunction<any>,
	createdAt?: FieldPolicy<any> | FieldReadFunction<any>,
	token?: FieldPolicy<any> | FieldReadFunction<any>
};
export type TokensMinAggregateKeySpecifier = ('id' | 'type' | 'userId' | 'expire' | 'createdAt' | 'token' | TokensMinAggregateKeySpecifier)[];
export type TokensMinAggregateFieldPolicy = {
	id?: FieldPolicy<any> | FieldReadFunction<any>,
	type?: FieldPolicy<any> | FieldReadFunction<any>,
	userId?: FieldPolicy<any> | FieldReadFunction<any>,
	expire?: FieldPolicy<any> | FieldReadFunction<any>,
	createdAt?: FieldPolicy<any> | FieldReadFunction<any>,
	token?: FieldPolicy<any> | FieldReadFunction<any>
};
export type UserKeySpecifier = ('id' | 'createdAt' | 'updatedAt' | 'name' | 'role' | 'email' | 'verified' | 'stripeId' | 'coins' | 'ccLast4' | 'patronageType' | UserKeySpecifier)[];
export type UserFieldPolicy = {
	id?: FieldPolicy<any> | FieldReadFunction<any>,
	createdAt?: FieldPolicy<any> | FieldReadFunction<any>,
	updatedAt?: FieldPolicy<any> | FieldReadFunction<any>,
	name?: FieldPolicy<any> | FieldReadFunction<any>,
	role?: FieldPolicy<any> | FieldReadFunction<any>,
	email?: FieldPolicy<any> | FieldReadFunction<any>,
	verified?: FieldPolicy<any> | FieldReadFunction<any>,
	stripeId?: FieldPolicy<any> | FieldReadFunction<any>,
	coins?: FieldPolicy<any> | FieldReadFunction<any>,
	ccLast4?: FieldPolicy<any> | FieldReadFunction<any>,
	patronageType?: FieldPolicy<any> | FieldReadFunction<any>
};
export type UserAvgAggregateKeySpecifier = ('coins' | 'ccLast4' | UserAvgAggregateKeySpecifier)[];
export type UserAvgAggregateFieldPolicy = {
	coins?: FieldPolicy<any> | FieldReadFunction<any>,
	ccLast4?: FieldPolicy<any> | FieldReadFunction<any>
};
export type UserCountAggregateKeySpecifier = ('id' | 'createdAt' | 'updatedAt' | 'name' | 'role' | 'email' | 'password' | 'verified' | 'stripeId' | 'coins' | 'ccLast4' | 'patronageType' | '_all' | UserCountAggregateKeySpecifier)[];
export type UserCountAggregateFieldPolicy = {
	id?: FieldPolicy<any> | FieldReadFunction<any>,
	createdAt?: FieldPolicy<any> | FieldReadFunction<any>,
	updatedAt?: FieldPolicy<any> | FieldReadFunction<any>,
	name?: FieldPolicy<any> | FieldReadFunction<any>,
	role?: FieldPolicy<any> | FieldReadFunction<any>,
	email?: FieldPolicy<any> | FieldReadFunction<any>,
	password?: FieldPolicy<any> | FieldReadFunction<any>,
	verified?: FieldPolicy<any> | FieldReadFunction<any>,
	stripeId?: FieldPolicy<any> | FieldReadFunction<any>,
	coins?: FieldPolicy<any> | FieldReadFunction<any>,
	ccLast4?: FieldPolicy<any> | FieldReadFunction<any>,
	patronageType?: FieldPolicy<any> | FieldReadFunction<any>,
	_all?: FieldPolicy<any> | FieldReadFunction<any>
};
export type UserGroupByKeySpecifier = ('id' | 'createdAt' | 'updatedAt' | 'name' | 'role' | 'email' | 'password' | 'verified' | 'stripeId' | 'coins' | 'ccLast4' | 'patronageType' | 'count' | 'avg' | 'sum' | 'min' | 'max' | UserGroupByKeySpecifier)[];
export type UserGroupByFieldPolicy = {
	id?: FieldPolicy<any> | FieldReadFunction<any>,
	createdAt?: FieldPolicy<any> | FieldReadFunction<any>,
	updatedAt?: FieldPolicy<any> | FieldReadFunction<any>,
	name?: FieldPolicy<any> | FieldReadFunction<any>,
	role?: FieldPolicy<any> | FieldReadFunction<any>,
	email?: FieldPolicy<any> | FieldReadFunction<any>,
	password?: FieldPolicy<any> | FieldReadFunction<any>,
	verified?: FieldPolicy<any> | FieldReadFunction<any>,
	stripeId?: FieldPolicy<any> | FieldReadFunction<any>,
	coins?: FieldPolicy<any> | FieldReadFunction<any>,
	ccLast4?: FieldPolicy<any> | FieldReadFunction<any>,
	patronageType?: FieldPolicy<any> | FieldReadFunction<any>,
	count?: FieldPolicy<any> | FieldReadFunction<any>,
	avg?: FieldPolicy<any> | FieldReadFunction<any>,
	sum?: FieldPolicy<any> | FieldReadFunction<any>,
	min?: FieldPolicy<any> | FieldReadFunction<any>,
	max?: FieldPolicy<any> | FieldReadFunction<any>
};
export type UserMaxAggregateKeySpecifier = ('id' | 'createdAt' | 'updatedAt' | 'name' | 'role' | 'email' | 'password' | 'verified' | 'stripeId' | 'coins' | 'ccLast4' | 'patronageType' | UserMaxAggregateKeySpecifier)[];
export type UserMaxAggregateFieldPolicy = {
	id?: FieldPolicy<any> | FieldReadFunction<any>,
	createdAt?: FieldPolicy<any> | FieldReadFunction<any>,
	updatedAt?: FieldPolicy<any> | FieldReadFunction<any>,
	name?: FieldPolicy<any> | FieldReadFunction<any>,
	role?: FieldPolicy<any> | FieldReadFunction<any>,
	email?: FieldPolicy<any> | FieldReadFunction<any>,
	password?: FieldPolicy<any> | FieldReadFunction<any>,
	verified?: FieldPolicy<any> | FieldReadFunction<any>,
	stripeId?: FieldPolicy<any> | FieldReadFunction<any>,
	coins?: FieldPolicy<any> | FieldReadFunction<any>,
	ccLast4?: FieldPolicy<any> | FieldReadFunction<any>,
	patronageType?: FieldPolicy<any> | FieldReadFunction<any>
};
export type UserMinAggregateKeySpecifier = ('id' | 'createdAt' | 'updatedAt' | 'name' | 'role' | 'email' | 'password' | 'verified' | 'stripeId' | 'coins' | 'ccLast4' | 'patronageType' | UserMinAggregateKeySpecifier)[];
export type UserMinAggregateFieldPolicy = {
	id?: FieldPolicy<any> | FieldReadFunction<any>,
	createdAt?: FieldPolicy<any> | FieldReadFunction<any>,
	updatedAt?: FieldPolicy<any> | FieldReadFunction<any>,
	name?: FieldPolicy<any> | FieldReadFunction<any>,
	role?: FieldPolicy<any> | FieldReadFunction<any>,
	email?: FieldPolicy<any> | FieldReadFunction<any>,
	password?: FieldPolicy<any> | FieldReadFunction<any>,
	verified?: FieldPolicy<any> | FieldReadFunction<any>,
	stripeId?: FieldPolicy<any> | FieldReadFunction<any>,
	coins?: FieldPolicy<any> | FieldReadFunction<any>,
	ccLast4?: FieldPolicy<any> | FieldReadFunction<any>,
	patronageType?: FieldPolicy<any> | FieldReadFunction<any>
};
export type UserResponseKeySpecifier = ('errors' | 'user' | UserResponseKeySpecifier)[];
export type UserResponseFieldPolicy = {
	errors?: FieldPolicy<any> | FieldReadFunction<any>,
	user?: FieldPolicy<any> | FieldReadFunction<any>
};
export type UserSumAggregateKeySpecifier = ('coins' | 'ccLast4' | UserSumAggregateKeySpecifier)[];
export type UserSumAggregateFieldPolicy = {
	coins?: FieldPolicy<any> | FieldReadFunction<any>,
	ccLast4?: FieldPolicy<any> | FieldReadFunction<any>
};
export type TypedTypePolicies = TypePolicies & {
	AffectedRowsOutput?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | AffectedRowsOutputKeySpecifier | (() => undefined | AffectedRowsOutputKeySpecifier),
		fields?: AffectedRowsOutputFieldPolicy,
	},
	AggregateSession?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | AggregateSessionKeySpecifier | (() => undefined | AggregateSessionKeySpecifier),
		fields?: AggregateSessionFieldPolicy,
	},
	AggregateTokens?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | AggregateTokensKeySpecifier | (() => undefined | AggregateTokensKeySpecifier),
		fields?: AggregateTokensFieldPolicy,
	},
	AggregateUser?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | AggregateUserKeySpecifier | (() => undefined | AggregateUserKeySpecifier),
		fields?: AggregateUserFieldPolicy,
	},
	FieldError?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | FieldErrorKeySpecifier | (() => undefined | FieldErrorKeySpecifier),
		fields?: FieldErrorFieldPolicy,
	},
	Mutation?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | MutationKeySpecifier | (() => undefined | MutationKeySpecifier),
		fields?: MutationFieldPolicy,
	},
	Query?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | QueryKeySpecifier | (() => undefined | QueryKeySpecifier),
		fields?: QueryFieldPolicy,
	},
	Session?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | SessionKeySpecifier | (() => undefined | SessionKeySpecifier),
		fields?: SessionFieldPolicy,
	},
	SessionCountAggregate?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | SessionCountAggregateKeySpecifier | (() => undefined | SessionCountAggregateKeySpecifier),
		fields?: SessionCountAggregateFieldPolicy,
	},
	SessionGroupBy?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | SessionGroupByKeySpecifier | (() => undefined | SessionGroupByKeySpecifier),
		fields?: SessionGroupByFieldPolicy,
	},
	SessionMaxAggregate?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | SessionMaxAggregateKeySpecifier | (() => undefined | SessionMaxAggregateKeySpecifier),
		fields?: SessionMaxAggregateFieldPolicy,
	},
	SessionMinAggregate?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | SessionMinAggregateKeySpecifier | (() => undefined | SessionMinAggregateKeySpecifier),
		fields?: SessionMinAggregateFieldPolicy,
	},
	Tokens?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | TokensKeySpecifier | (() => undefined | TokensKeySpecifier),
		fields?: TokensFieldPolicy,
	},
	TokensCountAggregate?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | TokensCountAggregateKeySpecifier | (() => undefined | TokensCountAggregateKeySpecifier),
		fields?: TokensCountAggregateFieldPolicy,
	},
	TokensGroupBy?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | TokensGroupByKeySpecifier | (() => undefined | TokensGroupByKeySpecifier),
		fields?: TokensGroupByFieldPolicy,
	},
	TokensMaxAggregate?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | TokensMaxAggregateKeySpecifier | (() => undefined | TokensMaxAggregateKeySpecifier),
		fields?: TokensMaxAggregateFieldPolicy,
	},
	TokensMinAggregate?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | TokensMinAggregateKeySpecifier | (() => undefined | TokensMinAggregateKeySpecifier),
		fields?: TokensMinAggregateFieldPolicy,
	},
	User?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | UserKeySpecifier | (() => undefined | UserKeySpecifier),
		fields?: UserFieldPolicy,
	},
	UserAvgAggregate?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | UserAvgAggregateKeySpecifier | (() => undefined | UserAvgAggregateKeySpecifier),
		fields?: UserAvgAggregateFieldPolicy,
	},
	UserCountAggregate?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | UserCountAggregateKeySpecifier | (() => undefined | UserCountAggregateKeySpecifier),
		fields?: UserCountAggregateFieldPolicy,
	},
	UserGroupBy?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | UserGroupByKeySpecifier | (() => undefined | UserGroupByKeySpecifier),
		fields?: UserGroupByFieldPolicy,
	},
	UserMaxAggregate?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | UserMaxAggregateKeySpecifier | (() => undefined | UserMaxAggregateKeySpecifier),
		fields?: UserMaxAggregateFieldPolicy,
	},
	UserMinAggregate?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | UserMinAggregateKeySpecifier | (() => undefined | UserMinAggregateKeySpecifier),
		fields?: UserMinAggregateFieldPolicy,
	},
	UserResponse?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | UserResponseKeySpecifier | (() => undefined | UserResponseKeySpecifier),
		fields?: UserResponseFieldPolicy,
	},
	UserSumAggregate?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | UserSumAggregateKeySpecifier | (() => undefined | UserSumAggregateKeySpecifier),
		fields?: UserSumAggregateFieldPolicy,
	}
};